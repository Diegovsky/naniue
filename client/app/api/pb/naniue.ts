// @generated by protobuf-ts 2.11.1 with parameter server_none
// @generated from protobuf file "naniue.proto" (package "naniue", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message naniue.Empty
 */
export interface Empty {
}
/**
 * @generated from protobuf message naniue.BaseReq
 */
export interface BaseReq {
    /**
     * @generated from protobuf field: string user_pn = 1
     */
    userPn: string;
}
/**
 * @generated from protobuf message naniue.Contacts
 */
export interface Contacts {
    /**
     * @generated from protobuf field: repeated naniue.Contact contacts = 1
     */
    contacts: Contact[];
}
/**
 * @generated from protobuf message naniue.GetContactReq
 */
export interface GetContactReq {
    /**
     * @generated from protobuf field: naniue.BaseReq base = 1
     */
    base?: BaseReq;
    /**
     * @generated from protobuf field: string contact = 2
     */
    contact: string;
}
/**
 * @generated from protobuf message naniue.AuthCode
 */
export interface AuthCode {
    /**
     * @generated from protobuf field: naniue.AuthMethod type = 1
     */
    type: AuthMethod;
    /**
     * @generated from protobuf field: string value = 2
     */
    value: string;
}
/**
 * @generated from protobuf message naniue.Error
 */
export interface Error {
    /**
     * @generated from protobuf field: string message = 1
     */
    message: string;
}
/**
 * @generated from protobuf message naniue.LoginRes
 */
export interface LoginRes {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "code";
        /**
         * @generated from protobuf field: naniue.AuthCode code = 1
         */
        code: AuthCode;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: naniue.Error error = 2
         */
        error: Error;
    } | {
        oneofKind: "alive";
        /**
         * @generated from protobuf field: naniue.Empty alive = 3
         */
        alive: Empty;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message naniue.LoginReq
 */
export interface LoginReq {
    /**
     * @generated from protobuf field: naniue.BaseReq base = 1
     */
    base?: BaseReq;
}
/**
 * @generated from protobuf message naniue.Contact
 */
export interface Contact {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: string pn = 2
     */
    pn: string;
    /**
     * @generated from protobuf field: string jid = 3
     */
    jid: string;
}
/**
 * @generated from protobuf message naniue.SendMessageReq
 */
export interface SendMessageReq {
    /**
     * @generated from protobuf field: naniue.BaseReq base = 1
     */
    base?: BaseReq;
    /**
     * @generated from protobuf field: string to_jid = 2
     */
    toJid: string;
    /**
     * @generated from protobuf field: string message = 3
     */
    message: string;
}
/**
 * @generated from protobuf message naniue.Message
 */
export interface Message {
    /**
     * @generated from protobuf field: string from_jid = 1
     */
    fromJid: string;
    /**
     * @generated from protobuf field: string chat_id = 2
     */
    chatId: string;
    /**
     * @generated from protobuf field: string message = 3
     */
    message: string;
    /**
     * @generated from protobuf field: bool is_forwarded = 4
     */
    isForwarded: boolean;
}
/**
 * @generated from protobuf enum naniue.AuthMethod
 */
export enum AuthMethod {
    /**
     * @generated from protobuf enum value: QR_CODE = 0;
     */
    QR_CODE = 0
}
// @generated message type with reflection information, may provide speed optimized methods
class Empty$Type extends MessageType<Empty> {
    constructor() {
        super("naniue.Empty", []);
    }
    create(value?: PartialMessage<Empty>): Empty {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Empty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Empty): Empty {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message naniue.Empty
 */
export const Empty = new Empty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BaseReq$Type extends MessageType<BaseReq> {
    constructor() {
        super("naniue.BaseReq", [
            { no: 1, name: "user_pn", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BaseReq>): BaseReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userPn = "";
        if (value !== undefined)
            reflectionMergePartial<BaseReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BaseReq): BaseReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_pn */ 1:
                    message.userPn = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BaseReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_pn = 1; */
        if (message.userPn !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userPn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message naniue.BaseReq
 */
export const BaseReq = new BaseReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Contacts$Type extends MessageType<Contacts> {
    constructor() {
        super("naniue.Contacts", [
            { no: 1, name: "contacts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Contact }
        ]);
    }
    create(value?: PartialMessage<Contacts>): Contacts {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contacts = [];
        if (value !== undefined)
            reflectionMergePartial<Contacts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Contacts): Contacts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated naniue.Contact contacts */ 1:
                    message.contacts.push(Contact.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Contacts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated naniue.Contact contacts = 1; */
        for (let i = 0; i < message.contacts.length; i++)
            Contact.internalBinaryWrite(message.contacts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message naniue.Contacts
 */
export const Contacts = new Contacts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetContactReq$Type extends MessageType<GetContactReq> {
    constructor() {
        super("naniue.GetContactReq", [
            { no: 1, name: "base", kind: "message", T: () => BaseReq },
            { no: 2, name: "contact", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetContactReq>): GetContactReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contact = "";
        if (value !== undefined)
            reflectionMergePartial<GetContactReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetContactReq): GetContactReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* naniue.BaseReq base */ 1:
                    message.base = BaseReq.internalBinaryRead(reader, reader.uint32(), options, message.base);
                    break;
                case /* string contact */ 2:
                    message.contact = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetContactReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* naniue.BaseReq base = 1; */
        if (message.base)
            BaseReq.internalBinaryWrite(message.base, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string contact = 2; */
        if (message.contact !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contact);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message naniue.GetContactReq
 */
export const GetContactReq = new GetContactReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthCode$Type extends MessageType<AuthCode> {
    constructor() {
        super("naniue.AuthCode", [
            { no: 1, name: "type", kind: "enum", T: () => ["naniue.AuthMethod", AuthMethod] },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthCode>): AuthCode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<AuthCode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthCode): AuthCode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* naniue.AuthMethod type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthCode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* naniue.AuthMethod type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message naniue.AuthCode
 */
export const AuthCode = new AuthCode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Error$Type extends MessageType<Error> {
    constructor() {
        super("naniue.Error", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Error>): Error {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<Error>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Error): Error {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Error, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message naniue.Error
 */
export const Error = new Error$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRes$Type extends MessageType<LoginRes> {
    constructor() {
        super("naniue.LoginRes", [
            { no: 1, name: "code", kind: "message", oneof: "result", T: () => AuthCode },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => Error },
            { no: 3, name: "alive", kind: "message", oneof: "result", T: () => Empty }
        ]);
    }
    create(value?: PartialMessage<LoginRes>): LoginRes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<LoginRes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRes): LoginRes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* naniue.AuthCode code */ 1:
                    message.result = {
                        oneofKind: "code",
                        code: AuthCode.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).code)
                    };
                    break;
                case /* naniue.Error error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: Error.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                case /* naniue.Empty alive */ 3:
                    message.result = {
                        oneofKind: "alive",
                        alive: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).alive)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* naniue.AuthCode code = 1; */
        if (message.result.oneofKind === "code")
            AuthCode.internalBinaryWrite(message.result.code, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* naniue.Error error = 2; */
        if (message.result.oneofKind === "error")
            Error.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* naniue.Empty alive = 3; */
        if (message.result.oneofKind === "alive")
            Empty.internalBinaryWrite(message.result.alive, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message naniue.LoginRes
 */
export const LoginRes = new LoginRes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginReq$Type extends MessageType<LoginReq> {
    constructor() {
        super("naniue.LoginReq", [
            { no: 1, name: "base", kind: "message", T: () => BaseReq }
        ]);
    }
    create(value?: PartialMessage<LoginReq>): LoginReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LoginReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginReq): LoginReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* naniue.BaseReq base */ 1:
                    message.base = BaseReq.internalBinaryRead(reader, reader.uint32(), options, message.base);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* naniue.BaseReq base = 1; */
        if (message.base)
            BaseReq.internalBinaryWrite(message.base, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message naniue.LoginReq
 */
export const LoginReq = new LoginReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Contact$Type extends MessageType<Contact> {
    constructor() {
        super("naniue.Contact", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pn", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "jid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Contact>): Contact {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.pn = "";
        message.jid = "";
        if (value !== undefined)
            reflectionMergePartial<Contact>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Contact): Contact {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string pn */ 2:
                    message.pn = reader.string();
                    break;
                case /* string jid */ 3:
                    message.jid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Contact, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string pn = 2; */
        if (message.pn !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pn);
        /* string jid = 3; */
        if (message.jid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.jid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message naniue.Contact
 */
export const Contact = new Contact$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendMessageReq$Type extends MessageType<SendMessageReq> {
    constructor() {
        super("naniue.SendMessageReq", [
            { no: 1, name: "base", kind: "message", T: () => BaseReq },
            { no: 2, name: "to_jid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SendMessageReq>): SendMessageReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.toJid = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<SendMessageReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendMessageReq): SendMessageReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* naniue.BaseReq base */ 1:
                    message.base = BaseReq.internalBinaryRead(reader, reader.uint32(), options, message.base);
                    break;
                case /* string to_jid */ 2:
                    message.toJid = reader.string();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendMessageReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* naniue.BaseReq base = 1; */
        if (message.base)
            BaseReq.internalBinaryWrite(message.base, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string to_jid = 2; */
        if (message.toJid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.toJid);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message naniue.SendMessageReq
 */
export const SendMessageReq = new SendMessageReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Message$Type extends MessageType<Message> {
    constructor() {
        super("naniue.Message", [
            { no: 1, name: "from_jid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "chat_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_forwarded", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Message>): Message {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fromJid = "";
        message.chatId = "";
        message.message = "";
        message.isForwarded = false;
        if (value !== undefined)
            reflectionMergePartial<Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Message): Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string from_jid */ 1:
                    message.fromJid = reader.string();
                    break;
                case /* string chat_id */ 2:
                    message.chatId = reader.string();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* bool is_forwarded */ 4:
                    message.isForwarded = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string from_jid = 1; */
        if (message.fromJid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fromJid);
        /* string chat_id = 2; */
        if (message.chatId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.chatId);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* bool is_forwarded = 4; */
        if (message.isForwarded !== false)
            writer.tag(4, WireType.Varint).bool(message.isForwarded);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message naniue.Message
 */
export const Message = new Message$Type();
/**
 * @generated ServiceType for protobuf service naniue.Wpp
 */
export const Wpp = new ServiceType("naniue.Wpp", [
    { name: "Login", options: {}, I: LoginReq, O: LoginRes },
    { name: "GetContacts", options: {}, I: BaseReq, O: Contacts },
    { name: "GetContact", options: {}, I: GetContactReq, O: Contact },
    { name: "SendMessage", options: {}, I: SendMessageReq, O: Empty },
    { name: "SubscribeMessages", serverStreaming: true, options: {}, I: BaseReq, O: Message }
]);
